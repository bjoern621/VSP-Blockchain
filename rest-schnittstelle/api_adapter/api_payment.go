/*
 * V$-GOIN API
 *
 * This is the official API for the interaction with the VS-Blockchain. This API focuses on payment-related use cases in the most easy and feasible way. All relevant keys and parameters are documented directly within the schema definitions.
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"net/http"
	"s3b/vsp-blockchain/rest-api/internal/common"
	transactionapi "s3b/vsp-blockchain/rest-api/transaktion"

	"bjoernblessin.de/go-utils/util/logger"
	"github.com/gin-gonic/gin"
)

type PaymentAPI struct {
	transactionService *transactionapi.TransaktionAPI
}

// NewPaymentAPI creates a new PaymentAPI with the given transaction service.
func NewPaymentAPI(transactionService *transactionapi.TransaktionAPI) *PaymentAPI {
	return &PaymentAPI{
		transactionService: transactionService,
	}
}

// Get /balance
// Returns the balance tied to the given public key hash
func (api *PaymentAPI) BalanceGet(c *gin.Context) {
	// Your handler implementation
	c.JSON(200, gin.H{"status": "OK"})
}

// Get /history
// Returns the history of transactions involving the given key hash
func (api *PaymentAPI) HistoryGet(c *gin.Context) {
	// Your handler implementation
	c.JSON(200, gin.H{"status": "OK"})
}

// Post /transaction
// Executes a transaction
func (api *PaymentAPI) TransactionPost(c *gin.Context) {
	// Parse request body
	var req TransactionPostRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		logger.Warnf("Failed to decode transaction request: %v", err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid JSON request body"})
		return
	}

	// Convert to domain request
	domainReq := common.TransactionRequest{
		RecipientVSAddress:  req.RecipientVSAddress,
		Amount:              uint64(req.Amount),
		SenderPrivateKeyWIF: req.SenderPrivateKeyWIF,
	}

	// Call the domain service
	result, validationErr := api.transactionService.CreateTransaction(domainReq)
	if validationErr != nil {
		logger.Warnf("Transaction request validation failed: %v", validationErr)
		if validationErr.IsAuthError {
			c.JSON(http.StatusUnauthorized, gin.H{"error": validationErr.Message})
		} else {
			c.JSON(http.StatusBadRequest, gin.H{"error": validationErr.Message})
		}
		return
	}

	// Handle result based on error code
	api.writeResponse(c, result)
}

// writeResponse writes the appropriate HTTP response based on the transaction result.
func (api *PaymentAPI) writeResponse(c *gin.Context, result *common.TransactionResult) {
	if result.Success {
		// 201 Created - Transaction successfully executed
		c.Status(http.StatusCreated)
		logger.Infof("Transaction created successfully: %s", result.TransactionID)
		return
	}

	switch result.ErrorCode {
	case common.ErrorCodeInvalidPrivateKey:
		// 401 Unauthorized - Invalid private key
		c.JSON(http.StatusUnauthorized, gin.H{"error": result.ErrorMessage})
	case common.ErrorCodeInsufficientFunds:
		// 400 Bad Request - Insufficient funds
		c.JSON(http.StatusBadRequest, gin.H{"error": result.ErrorMessage})
	case common.ErrorCodeValidationFailed, common.ErrorCodeBroadcastFailed:
		// 400 Bad Request - Validation or broadcast failed
		c.JSON(http.StatusBadRequest, gin.H{"error": result.ErrorMessage})
	default:
		// 500 Internal Server Error - Unexpected error
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Internal server error"})
	}

	logger.Warnf("Transaction failed: code=%d, message=%s", result.ErrorCode, result.ErrorMessage)
}
