/*
 * V$-GOIN API
 *
 * This is the official API for the interaction with the VS-Blockchain. This API focuses on payment-related use cases in the most easy and feasible way. All relevant keys and parameters are documented directly within the schema definitions.
 *
 * API version: 1.1.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"errors"
	"fmt"
	"net/http"
	"s3b/vsp-blockchain/rest-api/internal/common"
	"s3b/vsp-blockchain/rest-api/konto"
	transactionapi "s3b/vsp-blockchain/rest-api/transaktion"
	"s3b/vsp-blockchain/rest-api/transaktionsverlauf"

	"bjoernblessin.de/go-utils/util/logger"
	"github.com/gin-gonic/gin"
)

const internalServerError = "Internal server error"

type PaymentAPI struct {
	transactionService         *transactionapi.TransaktionAPI
	kontostandService          *konto.KontostandService
	transaktionsverlaufService *transaktionsverlauf.TransaktionsverlaufService
}

// NewPaymentAPI creates a new PaymentAPI with the given services.
func NewPaymentAPI(transactionService *transactionapi.TransaktionAPI, kontostandService *konto.KontostandService, transaktionsverlaufService *transaktionsverlauf.TransaktionsverlaufService) *PaymentAPI {
	return &PaymentAPI{
		transactionService:         transactionService,
		kontostandService:          kontostandService,
		transaktionsverlaufService: transaktionsverlaufService,
	}
}

// Get /balance
// Returns the balance tied to the given public key hash
func (api *PaymentAPI) BalanceGet(c *gin.Context) {
	// Extract VSAddress from query parameter
	vsAddress := c.Query("VSAddress")
	// Call the domain service
	result, err := api.kontostandService.GetBalance(vsAddress)
	if errors.Is(err, common.ErrInvalidAddress) {
		logger.Warnf("[api_payment] Balance request validation failed: %v", err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid V$Address"})
		return
	}
	var assetErr *common.AssetError
	if errors.As(err, &assetErr) {
		logger.Warnf("[api_payment] Balance request asset error: %v", err)
		c.JSON(http.StatusBadRequest, gin.H{"error": assetErr.Message})
		return
	}
	if err != nil {
		logger.Errorf("[api_payment] Failed to get balance: %v", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": internalServerError})
		return
	}
	fmt.Print(result)
	// Return successful response
	c.JSON(http.StatusOK, BalanceGet200Response{Balance: 0})
}

// Get /history
// Returns the history of transactions involving the given key hash
func (api *PaymentAPI) HistoryGet(c *gin.Context) {
	// Extract VSAddress from query parameter
	vsAddress := c.Query("vsAddress")

	// Call the domain service
	transactions, err := api.transaktionsverlaufService.GetHistory(vsAddress)
	if errors.Is(err, common.ErrInvalidAddress) {
		logger.Warnf("[api_payment] History request validation failed: %v", err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid V$Address"})
		return
	}
	var assetErr *common.AssetError
	if errors.As(err, &assetErr) {
		logger.Warnf("[api_payment] History request asset error: %v", err)
		c.JSON(http.StatusBadRequest, gin.H{"error": assetErr.Message})
		return
	}
	if err != nil {
		logger.Warnf("[api_payment] Failed to get history: %v", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": internalServerError})
		return
	}

	// Return successful response
	c.JSON(http.StatusOK, HistoryGet200Response{Transactions: transactions})
}

// Post /transaction
// Executes a transaction
func (api *PaymentAPI) TransactionPost(c *gin.Context) {
	// Parse request body
	var req TransactionPostRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		logger.Warnf("[api_payment] Failed to decode transaction request: %v", err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid JSON request body"})
		return
	}

	// Convert to domain request
	domainReq := common.TransactionRequest{
		RecipientVSAddress:  req.RecipientVSAddress,
		Amount:              uint64(req.Amount),
		SenderPrivateKeyWIF: req.SenderPrivateKeyWIF,
	}

	// Call the domain service
	result, validationErr := api.transactionService.CreateTransaction(domainReq)
	if validationErr != nil {
		logger.Warnf("[api_payment] Transaction request validation failed: %v", validationErr)
		if validationErr.IsAuthError {
			c.JSON(http.StatusUnauthorized, gin.H{"error": validationErr.Message})
		} else {
			c.JSON(http.StatusBadRequest, gin.H{"error": validationErr.Message})
		}
		return
	}

	// Handle result based on error code
	api.writeResponse(c, result)
}

// writeResponse writes the appropriate HTTP response based on the transaction result.
func (api *PaymentAPI) writeResponse(c *gin.Context, result *common.TransactionResult) {
	if result.Success {
		// 201 Created - Transaction successfully executed
		c.Status(http.StatusCreated)
		logger.Infof("[api_payment] Transaction created successfully: %s", result.TransactionID)
		return
	}

	switch result.ErrorCode {
	case common.ErrorCodeInvalidPrivateKey:
		// 401 Unauthorized - Invalid private key
		c.JSON(http.StatusUnauthorized, gin.H{"error": result.ErrorMessage})
	case common.ErrorCodeInsufficientFunds:
		// 400 Bad Request - Insufficient funds
		c.JSON(http.StatusBadRequest, gin.H{"error": result.ErrorMessage})
	case common.ErrorCodeValidationFailed:
		// 400 Bad Request - Validation failed
		c.JSON(http.StatusBadRequest, gin.H{"error": result.ErrorMessage})
	case common.ErrorCodeBroadcastFailed:
		// 500 Internal Server Error - Broadcast failed
		c.JSON(http.StatusInternalServerError, gin.H{"error": internalServerError})
	default:
		// 500 Internal Server Error - Unexpected error
		c.JSON(http.StatusInternalServerError, gin.H{"error": internalServerError})
	}

	logger.Warnf("[api_payment] Transaction failed: code=%d, message=%s", result.ErrorCode, result.ErrorMessage)
}
